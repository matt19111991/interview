/*
 1. Мы внутри функции?
    Да: смотрим пункт 2.
    Нет: this равен глобальному объекту.

 2. Мы внутри стрелочной функции?
    Да:
        значение this такое же, как и в функции на уровень выше (т.е. содержащей данную).
        Если же функция не содержится ни в какой другой, this — глобальный объект.
    Нет: смотрим пункт 3.

 3. Функция вызвана как конструктор (с помощью оператора new)?
    Да:
        this ссылается на новый объект, находящийся «в процессе конструкции».
        До вызова super() значения у this нет (обращение к нему вызовет ошибку),
        а после вызова super() он равняется новому объекту родительского класса.
    Нет: смотрим пункт 4.

 4. Функция создана с помощью метода bind?
    Да:
        значение this равняется значению первого аргумента,
        который мы передали в метод bind при создании данной функции.
        Повторным вызовом bind нельзя переопределить this
    Нет: смотрим пункт 5.

 5. Функция передана куда-то в качестве коллбэка или обработчика события?
    Да:
        для объявлении   обработчиков событий this === document.
        при срабатывании обработчиков событий this === currentTarget.
        [1, 2, 3].forEach(function() { console.log(this); }); - this === undefined.
    Нет: смотрим пункт 6.

 6. Функция вызвана с помощью метода apply или call?
    Да: this равняется первому аргументу, переданному соответствующему методу.
    Нет: смотрим пункт 7.

 7. Функция - это метод объекта?
    Да: this равняется объекту, у которого вызвана функция.
    Нет: смотрим пункт 8.

 8. Код выполняется в строгом режиме? ('use strict', ES6 модуль)
    Да: this равняется undefined.
    Нет: this равен глобальному объекту.
*/
const obj = {
    test: function(){
        (function(){
            console.log(this); // THIS === global object
        })(); //немедленно вызываемая функция внутри другой функции
    }
}

obj.test();
